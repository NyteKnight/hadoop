package org.apache.hadoop.security.token.loadtest;

import java.security.PrivilegedExceptionAction;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicLong;
import org.apache.hadoop.security.token.Token;


/**
 * Implementation of {@link TokenAction} to cancel delegation tokens,
 * using one of the tokens generated by the {@link PreloadTokens}
 * or the {@link RenewTokens} actions.
 */
public class CancelTokens extends TokenAction {
  private final LinkedBlockingQueue<UgiTokens> tokensToCancel;
  private final AtomicLong totalCancellations;

  public CancelTokens(double cancellationsPerSecond, LinkedBlockingQueue<UgiTokens> tokensToCancel,
      AtomicLong totalCancellations, AtomicBoolean shutdown) {
    super(cancellationsPerSecond, shutdown);
    this.tokensToCancel = tokensToCancel;
    this.totalCancellations = totalCancellations;
  }

  /**
   * Obtain one of the delegation tokens requested by
   * the {@link PreloadTokens} or the {@link RenewTokens} action.
   * @return UgiTokens object with tokens to renew and the
   *         UGI to renew them with.
   */
  @Override
  UgiTokens selectUgiTokens() throws InterruptedException {
    // Returns null if the queue is empty after waiting 100 ms
    return tokensToCancel.poll(100, TimeUnit.MILLISECONDS);
  }

  /**
   * Cancels the available tokens.
   * @param ugiTokens Object with tokens to cancel.
   */
  @Override
  PrivilegedExceptionAction<Void> getAction(UgiTokens ugiTokens) {
    return () -> {
      for (Token<?> token : ugiTokens.getTokens()) {
        token.cancel(config);
        totalCancellations.incrementAndGet();
      }
      return null;
    };
  }
}
