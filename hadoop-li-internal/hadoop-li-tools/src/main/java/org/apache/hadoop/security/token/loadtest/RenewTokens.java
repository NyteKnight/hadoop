package org.apache.hadoop.security.token.loadtest;

import java.security.PrivilegedExceptionAction;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicLong;
import org.apache.hadoop.security.token.Token;


/**
 * Implementation of {@link TokenAction} to renew delegation tokens,
 * using one of the tokens generated by the {@link RequestTokens} action.
 */
public class RenewTokens extends TokenAction {
  private final LinkedBlockingQueue<UgiTokens> tokensToRenew;
  private final LinkedBlockingQueue<UgiTokens> tokensToCancel;
  private final AtomicLong totalRenewals;

  public RenewTokens(double renewalsPerSecond, LinkedBlockingQueue<UgiTokens> tokensToRenew,
      LinkedBlockingQueue<UgiTokens> tokensToCancel, AtomicLong totalRenewals, AtomicBoolean shutdown) {
    super(renewalsPerSecond, shutdown);
    this.tokensToRenew = tokensToRenew;
    this.tokensToCancel = tokensToCancel;
    this.totalRenewals = totalRenewals;
  }

  /**
   * Obtain one of the delegation tokens requested by
   * the {@link RequestTokens} action.
   * @return UgiTokens object with tokens to renew and the
   *         UGI to renew them with.
   */
  @Override
  UgiTokens selectUgiTokens() throws InterruptedException {
    // Returns null if the queue is empty after waiting 100 ms
    return tokensToRenew.poll(100, TimeUnit.MILLISECONDS);
  }

  /**
   * Renews the available tokens and makes them available to
   * the {@link CancelTokens} action.
   * @param ugiTokens Object with tokens to renew
   */
  @Override
  PrivilegedExceptionAction<Void> getAction(UgiTokens ugiTokens) {
    return () -> {
      for (Token<?> token : ugiTokens.getTokens()) {
        token.renew(config);
        totalRenewals.incrementAndGet();
      }
      tokensToCancel.add(ugiTokens);
      return null;
    };
  }
}
